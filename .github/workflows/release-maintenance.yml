name: Release & Maintenance

on:
  push:
    tags:
      - 'v*.*.*'
  release:
    types: [ published ]
  schedule:
    # Weekly maintenance on Sundays at 4 AM UTC
    - cron: '0 4 * * 0'
    # Security updates on Mondays at 6 AM UTC
    - cron: '0 6 * * 1'
  workflow_dispatch:
    inputs:
      operation_type:
        description: 'Operation to perform'
        required: true
        type: choice
        options:
          - release
          - security-update
          - dependency-update
          - maintenance
        default: maintenance
      release_version:
        description: 'Release version (for release operation)'
        required: false
        type: string
      release_type:
        description: 'Release type'
        required: false
        type: choice
        options:
          - stable
          - beta
          - alpha
        default: stable
      auto_merge:
        description: 'Auto-merge updates (for update operations)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ============================================================================
  # OPERATION PLANNING
  # ============================================================================

  plan-operation:
    name: 📋 Plan Operation
    runs-on: ubuntu-latest

    outputs:
      operation_type: ${{ steps.plan.outputs.operation_type }}
      should_release: ${{ steps.plan.outputs.should_release }}
      should_update_deps: ${{ steps.plan.outputs.should_update_deps }}
      should_security_scan: ${{ steps.plan.outputs.should_security_scan }}
      should_maintenance: ${{ steps.plan.outputs.should_maintenance }}
      release_version: ${{ steps.plan.outputs.release_version }}
      release_type: ${{ steps.plan.outputs.release_type }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Determine operation type
      id: plan
      run: |
        echo "📋 Planning operation based on trigger..."

        # Determine operation type
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          OPERATION_TYPE="${{ github.event.inputs.operation_type }}"
        elif [[ "${{ github.event_name }}" == "push" ]] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
          OPERATION_TYPE="release"
        elif [[ "${{ github.event_name }}" == "release" ]]; then
          OPERATION_TYPE="release"
        elif [[ "${{ github.event_name }}" == "schedule" ]]; then
          case "${{ github.event.schedule }}" in
            "0 4 * * 0")  # Sunday 4 AM - maintenance
              OPERATION_TYPE="maintenance"
              ;;
            "0 6 * * 1")  # Monday 6 AM - security updates
              OPERATION_TYPE="security-update"
              ;;
          esac
        else
          OPERATION_TYPE="maintenance"
        fi

        echo "operation_type=$OPERATION_TYPE" >> $GITHUB_OUTPUT

        # Plan specific operations
        case "$OPERATION_TYPE" in
          "release")
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "should_security_scan=true" >> $GITHUB_OUTPUT
            echo "should_update_deps=false" >> $GITHUB_OUTPUT
            echo "should_maintenance=false" >> $GITHUB_OUTPUT

            # Determine release version
            if [[ "${{ github.event.inputs.release_version }}" ]]; then
              VERSION="${{ github.event.inputs.release_version }}"
            elif [[ "${{ github.ref_name }}" =~ ^v[0-9] ]]; then
              VERSION="${{ github.ref_name }}"
            else
              VERSION="v$(date +'%Y.%m.%d')"
            fi
            echo "release_version=$VERSION" >> $GITHUB_OUTPUT

            # Determine release type
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
            if [[ -z "$RELEASE_TYPE" ]]; then
              if [[ "$VERSION" == *"-alpha"* ]]; then
                RELEASE_TYPE="alpha"
              elif [[ "$VERSION" == *"-beta"* ]]; then
                RELEASE_TYPE="beta"
              else
                RELEASE_TYPE="stable"
              fi
            fi
            echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            ;;
          "security-update")
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "should_security_scan=true" >> $GITHUB_OUTPUT
            echo "should_update_deps=true" >> $GITHUB_OUTPUT
            echo "should_maintenance=false" >> $GITHUB_OUTPUT
            ;;
          "dependency-update")
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "should_security_scan=false" >> $GITHUB_OUTPUT
            echo "should_update_deps=true" >> $GITHUB_OUTPUT
            echo "should_maintenance=false" >> $GITHUB_OUTPUT
            ;;
          "maintenance")
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "should_security_scan=true" >> $GITHUB_OUTPUT
            echo "should_update_deps=false" >> $GITHUB_OUTPUT
            echo "should_maintenance=true" >> $GITHUB_OUTPUT
            ;;
        esac

        echo "🎯 Operation Plan:"
        echo "  Type: $OPERATION_TYPE"
        echo "  Release: $(cat $GITHUB_OUTPUT | grep should_release | cut -d= -f2)"
        echo "  Dependencies: $(cat $GITHUB_OUTPUT | grep should_update_deps | cut -d= -f2)"
        echo "  Security: $(cat $GITHUB_OUTPUT | grep should_security_scan | cut -d= -f2)"
        echo "  Maintenance: $(cat $GITHUB_OUTPUT | grep should_maintenance | cut -d= -f2)"

  # ============================================================================
  # COMPREHENSIVE SECURITY SCANNING
  # ============================================================================

  security-assessment:
    name: 🛡️ Security Assessment
    runs-on: ubuntu-latest
    needs: plan-operation
    if: needs.plan-operation.outputs.should_security_scan == 'true'

    strategy:
      matrix:
        assessment_type: [dependencies, configurations, compliance, vulnerabilities]
      fail-fast: false

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup security tools
      run: |
        echo "🔧 Setting up ${{ matrix.assessment_type }} security assessment..."

        case "${{ matrix.assessment_type }}" in
          "dependencies")
            pip3 install safety bandit semgrep
            npm install -g audit-ci || true
            ;;
          "configurations")
            sudo apt-get update
            sudo apt-get install -y apparmor-utils
            ;;
          "compliance")
            sudo apt-get update
            sudo apt-get install -y jq curl
            ;;
          "vulnerabilities")
            # Install trivy
            wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
            echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
            sudo apt-get update
            sudo apt-get install -y trivy
            ;;
        esac

    - name: Run security assessment
      run: |
        echo "🔍 Running ${{ matrix.assessment_type }} security assessment..."

        mkdir -p security-assessment

        case "${{ matrix.assessment_type }}" in
          "dependencies")
            echo "📦 Assessing dependency security..."

            # Python dependencies
            if find . -name "*.py" | head -1 >/dev/null 2>&1; then
              bandit -r . -f json -o security-assessment/bandit-report.json || true
              safety check --json > security-assessment/safety-report.json || true
            fi

            # Code analysis
            semgrep --config=auto --json --output=security-assessment/semgrep-report.json . || true

            # Package lists analysis
            find packages -name "*.list" | while read -r pkglist; do
              echo "Analyzing: $pkglist" >> security-assessment/package-analysis.log
              pkg_count=$(grep -v '^#' "$pkglist" | grep -v '^$' | wc -l)
              echo "  Packages: $pkg_count" >> security-assessment/package-analysis.log
            done
            ;;
          "configurations")
            echo "⚙️ Assessing configuration security..."

            # AppArmor profiles
            find configs/security -name "*apparmor*" -o -name "*.profile" | while read -r profile; do
              echo "Auditing: $profile" >> security-assessment/config-audit.log

              # Check for dangerous permissions
              if grep -q "allow.*write.*exec" "$profile" 2>/dev/null; then
                echo "⚠️ WARNING: Write+Execute in $profile" >> security-assessment/config-audit.log
              fi
            done

            # Firewall rules
            if [[ -f configs/security/ufw-gaming-rules.sh ]]; then
              echo "Auditing UFW rules..." >> security-assessment/config-audit.log
              if grep -q "allow.*any" configs/security/ufw-gaming-rules.sh; then
                echo "⚠️ WARNING: Permissive rules found" >> security-assessment/config-audit.log
              fi
            fi
            ;;
          "compliance")
            echo "📋 Assessing compliance..."

            cat > security-assessment/compliance-report.json << EOF
        {
          "assessment_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "repository": "${{ github.repository }}",
          "commit": "${{ github.sha }}",
          "compliance_checks": {
            "security_documentation": $([ -f docs/SECURITY.md ] && echo "true" || echo "false"),
            "security_configurations": $([ -d configs/security ] && echo "true" || echo "false"),
            "vulnerability_reporting": $(grep -qi "vulnerability" docs/README.md && echo "true" || echo "false"),
            "automated_updates": $([ -f .github/dependabot.yml ] && echo "true" || echo "false")
          }
        }
        EOF
            ;;
          "vulnerabilities")
            echo "🔍 Scanning for vulnerabilities..."

            # Filesystem scan
            trivy fs --format json --output security-assessment/trivy-fs-report.json . || true

            # Container scan if Dockerfile exists
            if [[ -f build/containers/Dockerfile.build ]]; then
              trivy config --format json --output security-assessment/trivy-config-report.json build/containers/ || true
            fi
            ;;
        esac

        echo "✅ ${{ matrix.assessment_type }} security assessment completed"

    - name: Upload security assessment
      uses: actions/upload-artifact@v4
      with:
        name: security-assessment-${{ matrix.assessment_type }}
        path: security-assessment/
        retention-days: 60

  # ============================================================================
  # DEPENDENCY MANAGEMENT
  # ============================================================================

  dependency-management:
    name: 📦 Dependency Management
    runs-on: ubuntu-latest
    needs: plan-operation
    if: needs.plan-operation.outputs.should_update_deps == 'true'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup dependency management
      run: |
        echo "🔧 Setting up dependency management..."

        # Configure git
        git config --global user.name "xanadOS Maintenance Bot"
        git config --global user.email "maintenance@xanados.org"

        # Install dependency tools
        pip3 install safety requests

    - name: Analyze current dependencies
      run: |
        echo "📊 Analyzing current dependencies..."

        mkdir -p dependency-analysis

        # Package inventory
        cat > dependency-analysis/package-inventory.sh << 'EOF'
        #!/bin/bash

        echo "=== xanadOS Package Inventory ===" > package-inventory.txt
        echo "Analysis Date: $(date)" >> package-inventory.txt
        echo "" >> package-inventory.txt

        # Core packages
        if [[ -d packages/core ]]; then
          core_count=$(find packages/core -name "*.list" -exec cat {} \; | grep -v '^#' | grep -v '^$' | wc -l)
          echo "Core packages: $core_count" >> package-inventory.txt
        fi

        # AUR packages
        if [[ -d packages/aur ]]; then
          aur_count=$(find packages/aur -name "*.list" -exec cat {} \; | grep -v '^#' | grep -v '^$' | wc -l)
          echo "AUR packages: $aur_count" >> package-inventory.txt
        fi

        # Security packages
        if [[ -f configs/security/security-packages.list ]]; then
          security_count=$(grep -v '^#' configs/security/security-packages.list | grep -v '^$' | wc -l)
          echo "Security packages: $security_count" >> package-inventory.txt
        fi
        EOF

        chmod +x dependency-analysis/package-inventory.sh
        cd dependency-analysis
        ./package-inventory.sh

    - name: Check for updates
      run: |
        echo "🔍 Checking for dependency updates..."

        UPDATE_TYPE="${{ needs.plan-operation.outputs.operation_type }}"

        cd dependency-analysis

        cat > check-updates.sh << 'EOF'
        #!/bin/bash

        UPDATE_TYPE="$1"

        echo "=== Dependency Update Check ===" > update-check.txt
        echo "Update Type: $UPDATE_TYPE" >> update-check.txt
        echo "Check Date: $(date)" >> update-check.txt
        echo "" >> update-check.txt

        case "$UPDATE_TYPE" in
          "security-update")
            echo "🛡️ Checking for security updates..." >> update-check.txt
            # In real implementation: query security advisories
            echo "Security updates checked" >> update-check.txt
            ;;
          "dependency-update")
            echo "📦 Checking for all dependency updates..." >> update-check.txt
            # In real implementation: check package repositories
            echo "All dependencies checked" >> update-check.txt
            ;;
        esac

        echo "Update check completed" >> update-check.txt
        EOF

        chmod +x check-updates.sh
        ./check-updates.sh "$UPDATE_TYPE"

    - name: Apply updates if needed
      run: |
        echo "🔄 Applying dependency updates..."

        # Create update branch
        BRANCH_NAME="dependency-updates-$(date +'%Y%m%d')"
        git checkout -b "$BRANCH_NAME"

        # Update package lists with timestamps
        find packages -name "*.list" | while read -r pkglist; do
          if [[ -f "$pkglist" ]]; then
            # Add update timestamp
            if ! grep -q "# Last updated:" "$pkglist"; then
              echo "" >> "$pkglist"
              echo "# Last updated: $(date)" >> "$pkglist"
            else
              sed -i "s/# Last updated:.*/# Last updated: $(date)/" "$pkglist"
            fi
          fi
        done

        # Check for changes
        if git diff --quiet; then
          echo "ℹ️ No dependency updates required"
          echo "HAS_UPDATES=false" >> $GITHUB_ENV
        else
          echo "✅ Dependency updates applied"
          echo "HAS_UPDATES=true" >> $GITHUB_ENV

          # Commit changes
          git add .
          git commit -m "chore: update dependencies (${{ needs.plan-operation.outputs.operation_type }})

          - Updated package list timestamps
          - Checked for ${{ needs.plan-operation.outputs.operation_type }}
          - Generated by automated maintenance workflow"

          # Push branch
          git push origin "$BRANCH_NAME"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
        fi

    - name: Create pull request for updates
      if: env.HAS_UPDATES == 'true'
      run: |
        echo "📋 Dependency updates ready for review"
        echo "🌿 Branch: ${BRANCH_NAME}"
        echo "🔄 Type: ${{ needs.plan-operation.outputs.operation_type }}"
        # In real implementation: create PR via GitHub API

    - name: Upload dependency analysis
      uses: actions/upload-artifact@v4
      with:
        name: dependency-analysis
        path: dependency-analysis/
        retention-days: 30

  # ============================================================================
  # RELEASE CREATION
  # ============================================================================

  create-release:
    name: 🚀 Create Release
    runs-on: ubuntu-latest
    needs: [plan-operation, security-assessment]
    if: needs.plan-operation.outputs.should_release == 'true'

    strategy:
      matrix:
        target: [x86-64-v3, x86-64-v4]
      fail-fast: false

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup release environment
      run: |
        echo "🔧 Setting up release environment for ${{ matrix.target }}..."

        # Install build dependencies
        sudo apt-get update
        sudo apt-get install -y \
          archiso \
          arch-install-scripts \
          squashfs-tools \
          libisoburn1 \
          dosfstools

    - name: Build release ISO
      run: |
        echo "🏗️ Building release ISO for ${{ matrix.target }}..."

        VERSION="${{ needs.plan-operation.outputs.release_version }}"
        RELEASE_TYPE="${{ needs.plan-operation.outputs.release_type }}"

        cd build

        # Create release configuration
        cat > release.conf << EOF
        VERSION="$VERSION"
        RELEASE_TYPE="$RELEASE_TYPE"
        BUILD_DATE="$(date '+%Y-%m-%d')"
        BUILD_COMMIT="${{ github.sha }}"
        TARGET="${{ matrix.target }}"
        EOF

        if [[ -x automation/build-pipeline.sh ]]; then
          ./automation/build-pipeline.sh \
            --target "${{ matrix.target }}" \
            --version "$VERSION" \
            --release \
            --config release.conf
        else
          echo "❌ Build pipeline not found"
          exit 1
        fi

        echo "✅ Release ISO built for ${{ matrix.target }}"

    - name: Generate release metadata
      run: |
        echo "📋 Generating release metadata..."

        cd build/releases

        for iso in *.iso; do
          if [[ -f "$iso" ]]; then
            # Generate checksums
            sha256sum "$iso" > "${iso}.sha256"
            sha512sum "$iso" > "${iso}.sha512"

            # Generate metadata
            cat > "${iso}.metadata.json" << EOF
        {
          "release_info": {
            "version": "${{ needs.plan-operation.outputs.release_version }}",
            "type": "${{ needs.plan-operation.outputs.release_type }}",
            "target": "${{ matrix.target }}",
            "build_date": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
            "commit": "${{ github.sha }}"
          },
          "file_info": {
            "filename": "$iso",
            "size_bytes": $(stat -c%s "$iso"),
            "sha256": "$(sha256sum "$iso" | cut -d' ' -f1)",
            "sha512": "$(sha512sum "$iso" | cut -d' ' -f1)"
          }
        }
        EOF
          fi
        done

    - name: Upload release artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-${{ matrix.target }}-${{ needs.plan-operation.outputs.release_version }}
        path: build/releases/
        retention-days: 180

  # ============================================================================
  # MAINTENANCE TASKS
  # ============================================================================

  maintenance:
    name: 🧹 System Maintenance
    runs-on: ubuntu-latest
    needs: plan-operation
    if: needs.plan-operation.outputs.should_maintenance == 'true'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Cleanup old artifacts
      run: |
        echo "🧹 Performing maintenance cleanup..."

        # Clean build cache directories
        if [[ -d build/cache ]]; then
          echo "Cleaning build cache..."
          find build/cache -type f -mtime +7 -delete 2>/dev/null || true
        fi

        # Clean test results
        if [[ -d testing/results ]]; then
          echo "Cleaning old test results..."
          find testing/results -type f -mtime +14 -delete 2>/dev/null || true
        fi

        # Clean temporary files
        find . -name "*.tmp" -o -name "*.temp" -delete 2>/dev/null || true

        echo "✅ Cleanup completed"

    - name: Update documentation
      run: |
        echo "📖 Updating documentation..."

        if [[ -x docs/doc-system-enhancer.sh ]]; then
          docs/doc-system-enhancer.sh --auto-fix --generate-index
        fi

        echo "✅ Documentation updated"

    - name: Validate configurations
      run: |
        echo "⚙️ Validating configurations..."

        # Validate package lists
        find packages -name "*.list" | while read -r pkglist; do
          if [[ -f "$pkglist" ]]; then
            # Check for duplicates
            duplicates=$(grep -v '^#' "$pkglist" | grep -v '^$' | sort | uniq -d)
            if [[ -n "$duplicates" ]]; then
              echo "⚠️ Duplicates in $pkglist: $duplicates"
            fi
          fi
        done

        # Validate security configs
        if [[ -d configs/security ]]; then
          find configs/security -name "*.conf" -o -name "*.profile" | while read -r config; do
            echo "Validating: $config"
          done
        fi

        echo "✅ Configuration validation completed"

  # ============================================================================
  # COMPREHENSIVE REPORTING
  # ============================================================================

  generate-report:
    name: 📊 Generate Operation Report
    runs-on: ubuntu-latest
    needs: [plan-operation, security-assessment, dependency-management, create-release, maintenance]
    if: always()

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts/

    - name: Generate comprehensive report
      run: |
        echo "📊 Generating operation report..."

        mkdir -p operation-report

        OPERATION_TYPE="${{ needs.plan-operation.outputs.operation_type }}"

        cat > operation-report/operation-summary.md << EOF
        # xanadOS $OPERATION_TYPE Report

        **Operation**: $OPERATION_TYPE
        **Date**: $(date '+%Y-%m-%d %H:%M:%S UTC')
        **Trigger**: ${{ github.event_name }}
        **Workflow Run**: ${{ github.run_id }}

        ## Operation Results

        ### Security Assessment
        **Status**: ${{ needs.security-assessment.result }}
        **Assessments**: Dependencies, Configurations, Compliance, Vulnerabilities

        ### Dependency Management
        **Status**: ${{ needs.dependency-management.result }}
        **Operation**: ${{ needs.plan-operation.outputs.operation_type }}

        ### Release Creation
        **Status**: ${{ needs.create-release.result }}
        **Version**: ${{ needs.plan-operation.outputs.release_version }}
        **Type**: ${{ needs.plan-operation.outputs.release_type }}

        ### Maintenance
        **Status**: ${{ needs.maintenance.result }}
        **Tasks**: Cleanup, Documentation, Validation

        ## Artifacts Generated

        EOF

        # List release artifacts
        if [[ -d artifacts ]] && find artifacts -name "*release*" | head -1 >/dev/null 2>&1; then
          echo "### Release Artifacts" >> operation-report/operation-summary.md
          find artifacts -name "*.iso" | while read -r iso; do
            filename=$(basename "$iso")
            size=$(stat -c%s "$iso" 2>/dev/null || echo "unknown")
            echo "- **$filename** (Size: $size bytes)" >> operation-report/operation-summary.md
          done
        fi

        # Security assessment summary
        if [[ -d artifacts ]] && find artifacts -name "*security*" | head -1 >/dev/null 2>&1; then
          echo "### Security Assessment Results" >> operation-report/operation-summary.md
          echo "- Comprehensive security assessment completed" >> operation-report/operation-summary.md
          echo "- Results available in security assessment artifacts" >> operation-report/operation-summary.md
        fi

        cat >> operation-report/operation-summary.md << EOF

        ## Next Steps

        EOF

        case "$OPERATION_TYPE" in
          "release")
            cat >> operation-report/operation-summary.md << EOF
        1. Download and test release ISO artifacts
        2. Verify checksums and signatures
        3. Update release documentation
        4. Announce release to community
        EOF
            ;;
          "security-update"|"dependency-update")
            cat >> operation-report/operation-summary.md << EOF
        1. Review dependency update pull request
        2. Test updated dependencies
        3. Merge updates after validation
        4. Monitor for any issues
        EOF
            ;;
          "maintenance")
            cat >> operation-report/operation-summary.md << EOF
        1. Review maintenance log for any issues
        2. Verify documentation updates
        3. Check system health metrics
        4. Schedule next maintenance window
        EOF
            ;;
        esac

        cat >> operation-report/operation-summary.md << EOF

        ---

        *Generated automatically by xanadOS Release & Maintenance workflow*
        EOF

        # Copy relevant artifacts
        cp -r artifacts/* operation-report/ 2>/dev/null || true

        echo "✅ Operation report generated"

    - name: Upload operation report
      uses: actions/upload-artifact@v4
      with:
        name: operation-report-${{ needs.plan-operation.outputs.operation_type }}
        path: operation-report/
        retention-days: 180

    - name: Operation summary
      run: |
        echo "🎉 ${{ needs.plan-operation.outputs.operation_type }} operation completed!"
        echo "📊 Operation: ${{ needs.plan-operation.outputs.operation_type }}"
        echo "🛡️ Security: ${{ needs.security-assessment.result }}"
        echo "📦 Dependencies: ${{ needs.dependency-management.result }}"
        echo "🚀 Release: ${{ needs.create-release.result }}"
        echo "🧹 Maintenance: ${{ needs.maintenance.result }}"
        echo "🔗 Report: Available in operation-report artifact"
